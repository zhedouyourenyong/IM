每个消息有一个唯一Id，根据唯一ID进行幂等性保证。

客户端通过会话ID进行排序。

ACK消息的消息体是要确认的消息的ID。

ackWin：负责消息的第一次发送和之后的超时重推.
transfer没有ackWin.

已消费的消息：
发送ack之后对方没收到，会重发消息，所以收到之后需要检查消息ID，如果是已经消费过的直接发送ack，如果不是再具体处理。
每个ackWin都在redis中有个set维护自己消费过的消息。

客户端a和b在服务端1
客户端c和d在服务端2

a->b：
不需要经过transfer，直接交给服务端1，检查消息ID,判断之后是发送ACK还是交给ackWin处理。
交给ackWin后，服务器收到b的ack，设置消息为已消费再从ackWin中删除，然后再给a发送ack。

a->d:
需要经过transfer，消息先到达服务器1，服务器1直接转发给transfer，transfer找到客户端d所在的服务器2，
发送消息给服务器2，服务器2的ackWin存一份，发送给d，收到d的ack后，发送给服务器1，服务器再发送给a。
这种情况使用的是客户端a和服务端2的ackWin，服务端1和transfer只做中转。

为什么服务端1与transfer之间的channel不做一个ackWin？
服务端1通过transfer转发消息到服务端2时，是通过负责均衡选择一个transfer，不能保证重发时选择的是同一个transfer。
并且transfer只起中转作用，重推只有server的ackWin负责。

服务器总结：
检查消息ID，看是否消费过。
已消费：重发ACK。
未消费：交给ackWin，发送给客户端。
收到ack：设置消息已消费，从ackWin中删除，发送ack给发送者。





和目标client直接的server才负责消息的重推

六个模块：
c：客户端     s：服务器
c1，c2，c3.
s1，s2.
transfer。

c1连接s1
c2和c3连接s2；
s1和s2均连接t；

消息流程：
不需要转发，c2到c3：
消息从c2到达s2，目标连接c3在s2中，交给ackWin。
c3收到消息后发送ack给s2，s2收到后将消息从ackWin中删除。





需要转发，c1到c2：
消息从c1到s1，目标连接c2不在s1，交给transfer。
transfer转发给s2，目标连接在c2在s2中，消息交给ackWin。



ack流程：
c3->s2->c2:
ack从c3到s2，s2根据ack消息体的消息Id取消ackWin中的重推，设置消息为已经消费，再发送ack到c2，取消c2的重推。


c2->s2->t->s1->c1:
ack首先到达s2，取消s2中ack的重推。s2将ack发给t，t发给c1，取消c1的重推。



服务器收到的ack来源及处理：
来自客户端：代表客户端已经消费消息，将消息从ackWin中删除。
来自transfer：转发给对应服务器，由其下推给客户端.


服务端收到的msg来源及处理：首先检查消息是否被消费过。
来自客户端：下发或转发
来自transfer：目标channel一定在本机，交给ackWin.



如果ack来自transfer，说明当前服务器只做中转作用，直接下发给client。
如果ack来自client2，则当前服务器2的ackWin有负责该消息重推，需要将消息设置为已消费，并将消息ID从ackWin中删除。
   然后再将ack发送给transfer，让transfer发给服务器1，再发给client1，取消client1的消息重推。
如果client2发送的ack没有到达服务器2，则服务器2会重推直到收到ack。
如果服务器2发给client1的ack中途丢失，则client1会重推消息到服务器2，服务器2检查消息ID为已消费则直接再次发送ack。



客户端重推消息到ackWin？？
怎么保证幂等性

目标客户端收到消息后发送一次ack，如果ack中途丢失，会触发消息重推，这时再次发送ack。
